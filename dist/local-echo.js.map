{"version":3,"file":"local-echo.js","mappings":"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","sources":["webpack://LocalEchoController/./node_modules/shell-quote/index.js","webpack://LocalEchoController/./node_modules/shell-quote/parse.js","webpack://LocalEchoController/./node_modules/shell-quote/quote.js","webpack://LocalEchoController/webpack/bootstrap","webpack://LocalEchoController/webpack/runtime/define property getters","webpack://LocalEchoController/webpack/runtime/hasOwnProperty shorthand","webpack://LocalEchoController/./lib/HistoryController.js","webpack://LocalEchoController/./lib/Utils.js","webpack://LocalEchoController/./lib/LocalEchoController.js","webpack://LocalEchoController/./index.js"],"sourcesContent":["'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * The history controller provides an ring-buffer\n */\nexport class HistoryController {\n\tconstructor(size) {\n\t\tthis.size = size\n\t\tthis.entries = []\n\t\tthis.cursor = 0\n\t}\n\n\t/**\n\t * Push an entry and maintain ring buffer size\n\t */\n\tpush(entry) {\n\t\t// Skip empty entries\n\t\tif (entry.trim() === '') return\n\t\t// Skip duplicate entries\n\t\tconst lastEntry = this.entries[this.entries.length - 1]\n\t\tif (entry == lastEntry) return\n\t\t// Keep track of entries\n\t\tthis.entries.push(entry)\n\t\tif (this.entries.length > this.size) {\n\t\t\tthis.entries.pop(0)\n\t\t}\n\t\tthis.cursor = this.entries.length\n\t}\n\n\t/**\n\t * Rewind history cursor on the last entry\n\t */\n\trewind() {\n\t\tthis.cursor = this.entries.length\n\t}\n\n\t/**\n\t * Returns the previous entry\n\t */\n\tgetPrevious() {\n\t\tconst idx = Math.max(0, this.cursor - 1)\n\t\tthis.cursor = idx\n\t\treturn this.entries[idx]\n\t}\n\n\t/**\n\t * Returns the next entry\n\t */\n\tgetNext() {\n\t\tconst idx = Math.min(this.entries.length, this.cursor + 1)\n\t\tthis.cursor = idx\n\t\treturn this.entries[idx]\n\t}\n}\n","import { parse } from 'shell-quote'\n\n/**\n * Detects all the word boundaries on the given input\n */\nexport function wordBoundaries(input, leftSide = true) {\n\tlet match\n\tconst words = []\n\tconst rx = /\\w+/g\n\n\twhile ((match = rx.exec(input))) {\n\t\tif (leftSide) {\n\t\t\twords.push(match.index)\n\t\t} else {\n\t\t\twords.push(match.index + match[0].length)\n\t\t}\n\t}\n\n\treturn words\n}\n\n/**\n * The closest left (or right) word boundary of the given input at the\n * given offset.\n */\nexport function closestLeftBoundary(input, offset) {\n\tconst found = wordBoundaries(input, true)\n\t\t.reverse()\n\t\t.find(x => x < offset)\n\treturn found == null ? 0 : found\n}\nexport function closestRightBoundary(input, offset) {\n\tconst found = wordBoundaries(input, false).find(x => x > offset)\n\treturn found == null ? input.length : found\n}\n\n/**\n * Convert offset at the given input to col/row location\n *\n * This function is not optimized and practically emulates via brute-force\n * the navigation on the terminal, wrapping when they reach the column width.\n */\nexport function offsetToColRow(input, offset, maxCols) {\n\tlet row = 0,\n\t\tcol = 0\n\n\tfor (let i = 0; i < offset; ++i) {\n\t\tconst chr = input.charAt(i)\n\t\tif (chr == '\\n') {\n\t\t\tcol = 0\n\t\t\trow += 1\n\t\t} else {\n\t\t\tcol += 1\n\t\t\tif (col > maxCols) {\n\t\t\t\tcol = 0\n\t\t\t\trow += 1\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { row, col }\n}\n\n/**\n * Counts the lines in the given input\n */\nexport function countLines(input, maxCols) {\n\treturn offsetToColRow(input, input.length, maxCols).row + 1\n}\n\n/**\n * Checks if there is an incomplete input\n *\n * An incomplete input is considered:\n * - An input that contains unterminated single quotes\n * - An input that contains unterminated double quotes\n * - An input that ends with \"\\\"\n * - An input that has an incomplete boolean shell expression (&& and ||)\n * - An incomplete pipe expression (|)\n */\nexport function isIncompleteInput(input) {\n\t// Empty input is not incomplete\n\tif (input.trim() == '') {\n\t\treturn false\n\t}\n\n\t// Check for dangling single-quote strings\n\tif ((input.match(/'/g) || []).length % 2 !== 0) {\n\t\treturn true\n\t}\n\t// Check for dangling double-quote strings\n\tif ((input.match(/\"/g) || []).length % 2 !== 0) {\n\t\treturn true\n\t}\n\t// Check for dangling boolean or pipe operations\n\tif (\n\t\tinput\n\t\t\t.split(/(\\|\\||\\||&&)/g)\n\t\t\t.pop()\n\t\t\t.trim() == ''\n\t) {\n\t\treturn true\n\t}\n\t// Check for tailing slash\n\tif (input.endsWith('\\\\') && !input.endsWith('\\\\\\\\')) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n/**\n * Returns true if the expression ends on a tailing whitespace\n */\nexport function hasTailingWhitespace(input) {\n\treturn input.match(/[^\\\\][ \\t]$/m) != null\n}\n\n/**\n * Returns the last expression in the given input\n */\nexport function getLastToken(input) {\n\t// Empty expressions\n\tif (input.trim() === '') return ''\n\tif (hasTailingWhitespace(input)) return ''\n\n\t// Last token\n\tconst tokens = parse(input)\n\treturn tokens.pop() || ''\n}\n\n/**\n * Returns the auto-complete candidates for the given input\n */\nexport function collectAutocompleteCandidates(callbacks, input) {\n\tconst tokens = parse(input)\n\tlet index = tokens.length - 1\n\tlet expr = tokens[index] || ''\n\n\t// Empty expressions\n\tif (input.trim() === '') {\n\t\tindex = 0\n\t\texpr = ''\n\t} else if (hasTailingWhitespace(input)) {\n\t\t// Expressions with danging space\n\t\tindex += 1\n\t\texpr = ''\n\t}\n\n\t// Collect all auto-complete candidates from the callbacks\n\tconst all = callbacks.reduce((candidates, { fn, args }) => {\n\t\ttry {\n\t\t\treturn candidates.concat(fn(index, tokens, ...args))\n\t\t} catch (e) {\n\t\t\tconsole.error('Auto-complete error:', e)\n\t\t\treturn candidates\n\t\t}\n\t}, [])\n\n\t// Filter only the ones starting with the expression\n\treturn all.filter(txt => txt.startsWith(expr))\n}\n\nexport function getSharedFragment(fragment, candidates) {\n\t// end loop when fragment length = first candidate length\n\tif (fragment.length >= candidates[0].length) return fragment\n\n\t// save old fragemnt\n\tconst oldFragment = fragment\n\n\t// get new fragment\n\tfragment += candidates[0].slice(\n\t\tfragment.length,\n\t\tfragment.length + 1,\n\t)\n\n\tfor (let i = 0; i < candidates.length; i++) {\n\t\t// return null when there's a wrong candidate\n\t\tif (!candidates[i].startsWith(oldFragment)) return null\n\n\t\tif (!candidates[i].startsWith(fragment)) {\n\t\t\treturn oldFragment\n\t\t}\n\t}\n\n\treturn getSharedFragment(fragment, candidates)\n}\n","import { HistoryController } from './HistoryController'\nimport {\n\tclosestLeftBoundary,\n\tclosestRightBoundary,\n\tcollectAutocompleteCandidates,\n\tcountLines,\n\tgetLastToken,\n\thasTailingWhitespace,\n\tisIncompleteInput,\n\toffsetToColRow,\n\tgetSharedFragment,\n} from './Utils'\n\n/**\n * A local terminal controller is responsible for displaying messages\n * and handling local echo for the terminal.\n *\n * Local echo supports most of bash-like input primitives. Namely:\n * - Arrow navigation on the input\n * - Alt-arrow for word-boundary navigation\n * - Alt-backspace for word-boundary deletion\n * - Multi-line input for incomplete commands\n * - Auto-complete hooks\n */\nexport default class LocalEchoController {\n\tconstructor(term = null, options = {}) {\n\t\tthis.term = term\n\t\tthis._handleTermData = this.handleTermData.bind(this)\n\t\tthis._handleTermResize = this.handleTermResize.bind(this)\n\n\t\tthis.history = new HistoryController(options.historySize || 10)\n\t\tthis.maxAutocompleteEntries =\n\t\t\toptions.maxAutocompleteEntries || 100\n\n\t\tthis._autocompleteHandlers = []\n\t\tthis._active = false\n\t\tthis._input = ''\n\t\tthis._cursor = 0\n\t\tthis._activePrompt = null\n\t\tthis._activeCharPrompt = null\n\t\tthis._termSize = {\n\t\t\tcols: 0,\n\t\t\trows: 0,\n\t\t}\n\n\t\tthis._disposables = []\n\n\t\tif (term) {\n\t\t\tif (term.loadAddon) term.loadAddon(this)\n\t\t\telse this.attach()\n\t\t}\n\t}\n\n\t// xterm.js new plugin API:\n\tactivate(term) {\n\t\tthis.term = term\n\t\tthis.attach()\n\t}\n\tdispose() {\n\t\tthis.detach()\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////\n\t// User-Facing API\n\t/////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Detach the controller from the terminal\n\t */\n\tdetach() {\n\t\tif (this.term.off) {\n\t\t\tthis.term.off('data', this._handleTermData)\n\t\t\tthis.term.off('resize', this._handleTermResize)\n\t\t} else {\n\t\t\tthis._disposables.forEach(d => d.dispose())\n\t\t\tthis._disposables = []\n\t\t}\n\t}\n\n\t/**\n\t * Attach controller to the terminal, handling events\n\t */\n\tattach() {\n\t\tif (this.term.on) {\n\t\t\tthis.term.on('data', this._handleTermData)\n\t\t\tthis.term.on('resize', this._handleTermResize)\n\t\t} else {\n\t\t\tthis._disposables.push(this.term.onData(this._handleTermData))\n\t\t\tthis._disposables.push(\n\t\t\t\tthis.term.onResize(this._handleTermResize),\n\t\t\t)\n\t\t}\n\t\tthis._termSize = {\n\t\t\tcols: this.term.cols,\n\t\t\trows: this.term.rows,\n\t\t}\n\t}\n\n\t/**\n\t * Register a handler that will be called to satisfy auto-completion\n\t */\n\taddAutocompleteHandler(fn, ...args) {\n\t\tthis._autocompleteHandlers.push({\n\t\t\tfn,\n\t\t\targs,\n\t\t})\n\t}\n\n\t/**\n\t * Remove a previously registered auto-complete handler\n\t */\n\tremoveAutocompleteHandler(fn) {\n\t\tconst idx = this._autocompleteHandlers.findIndex(e => e.fn === fn)\n\t\tif (idx === -1) return\n\n\t\tthis._autocompleteHandlers.splice(idx, 1)\n\t}\n\n\t/**\n\t * Return a promise that will resolve when the user has completed\n\t * typing a single line\n\t */\n\tread(prompt, continuationPrompt = '> ') {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.term.write(prompt)\n\t\t\tthis._activePrompt = {\n\t\t\t\tprompt,\n\t\t\t\tcontinuationPrompt,\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t}\n\n\t\t\tthis._input = ''\n\t\t\tthis._cursor = 0\n\t\t\tthis._active = true\n\t\t})\n\t}\n\n\t/**\n\t * Return a promise that will be resolved when the user types a single\n\t * character.\n\t *\n\t * This can be active in addition to `.read()` and will be resolved in\n\t * priority before it.\n\t */\n\treadChar(prompt) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.term.write(prompt)\n\t\t\tthis._activeCharPrompt = {\n\t\t\t\tprompt,\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Abort a pending read operation\n\t */\n\tabortRead(reason = 'aborted') {\n\t\tif (\n\t\t\tthis._activePrompt != null ||\n\t\t\tthis._activeCharPrompt != null\n\t\t) {\n\t\t\tthis.term.write('\\r\\n')\n\t\t}\n\t\tif (this._activePrompt != null) {\n\t\t\tthis._activePrompt.reject(reason)\n\t\t\tthis._activePrompt = null\n\t\t}\n\t\tif (this._activeCharPrompt != null) {\n\t\t\tthis._activeCharPrompt.reject(reason)\n\t\t\tthis._activeCharPrompt = null\n\t\t}\n\t\tthis._active = false\n\t}\n\n\t/**\n\t * Prints a message and changes line\n\t */\n\tprintln(message) {\n\t\tthis.print(message + '\\n')\n\t}\n\n\t/**\n\t * Prints a message and properly handles new-lines\n\t */\n\tprint(message) {\n\t\tconst normInput = message.replace(/[\\r\\n]+/g, '\\n')\n\t\tthis.term.write(normInput.replace(/\\n/g, '\\r\\n'))\n\t}\n\n\t/**\n\t * Prints a list of items using a wide-format\n\t */\n\tprintWide(items, padding = 2) {\n\t\tif (items.length == 0) return println('')\n\n\t\t// Compute item sizes and matrix row/cols\n\t\tconst itemWidth =\n\t\t\titems.reduce((width, item) => Math.max(width, item.length), 0) +\n\t\t\tpadding\n\t\tconst wideCols = Math.floor(this._termSize.cols / itemWidth)\n\t\tconst wideRows = Math.ceil(items.length / wideCols)\n\n\t\t// Print matrix\n\t\tlet i = 0\n\t\tfor (let row = 0; row < wideRows; ++row) {\n\t\t\tlet rowStr = ''\n\n\t\t\t// Prepare columns\n\t\t\tfor (let col = 0; col < wideCols; ++col) {\n\t\t\t\tif (i < items.length) {\n\t\t\t\t\tlet item = items[i++]\n\t\t\t\t\titem += ' '.repeat(itemWidth - item.length)\n\t\t\t\t\trowStr += item\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.println(rowStr)\n\t\t}\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////\n\t// Internal API\n\t/////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Apply prompts to the given input\n\t */\n\tapplyPrompts(input) {\n\t\tconst prompt = (this._activePrompt || {}).prompt || ''\n\t\tconst continuationPrompt =\n\t\t\t(this._activePrompt || {}).continuationPrompt || ''\n\n\t\treturn prompt + input.replace(/\\n/g, '\\n' + continuationPrompt)\n\t}\n\n\t/**\n\t * Advances the `offset` as required in order to accompany the prompt\n\t * additions to the input.\n\t */\n\tapplyPromptOffset(input, offset) {\n\t\tconst newInput = this.applyPrompts(input.substr(0, offset))\n\t\treturn newInput.length\n\t}\n\n\t/**\n\t * Clears the current prompt\n\t *\n\t * This function will erase all the lines that display the current prompt\n\t * and move the cursor in the beginning of the first line of the prompt.\n\t */\n\tclearInput() {\n\t\tconst currentPrompt = this.applyPrompts(this._input)\n\n\t\t// Get the overall number of lines to clear\n\t\tconst allRows = countLines(currentPrompt, this._termSize.cols)\n\n\t\t// Get the line we are currently in\n\t\tconst promptCursor = this.applyPromptOffset(\n\t\t\tthis._input,\n\t\t\tthis._cursor,\n\t\t)\n\t\tconst { col, row } = offsetToColRow(\n\t\t\tcurrentPrompt,\n\t\t\tpromptCursor,\n\t\t\tthis._termSize.cols,\n\t\t)\n\n\t\t// First move on the last line\n\t\tconst moveRows = allRows - row - 1\n\t\tfor (var i = 0; i < moveRows; ++i) this.term.write('\\x1B[E')\n\n\t\t// Clear current input line(s)\n\t\tthis.term.write('\\r\\x1B[K')\n\t\tfor (var i = 1; i < allRows; ++i) this.term.write('\\x1B[F\\x1B[K')\n\t}\n\n\t/**\n\t * Replace input with the new input given\n\t *\n\t * This function clears all the lines that the current input occupies and\n\t * then replaces them with the new input.\n\t */\n\tsetInput(newInput, clearInput = true) {\n\t\t// Clear current input\n\t\tif (clearInput) this.clearInput()\n\n\t\t// Write the new input lines, including the current prompt\n\t\tconst newPrompt = this.applyPrompts(newInput)\n\t\tthis.print(newPrompt)\n\n\t\t// Trim cursor overflow\n\t\tif (this._cursor > newInput.length) {\n\t\t\tthis._cursor = newInput.length\n\t\t}\n\n\t\t// Move the cursor to the appropriate row/col\n\t\tconst newCursor = this.applyPromptOffset(newInput, this._cursor)\n\t\tconst newLines = countLines(newPrompt, this._termSize.cols)\n\t\tconst { col, row } = offsetToColRow(\n\t\t\tnewPrompt,\n\t\t\tnewCursor,\n\t\t\tthis._termSize.cols,\n\t\t)\n\t\tconst moveUpRows = newLines - row - 1\n\n\t\tthis.term.write('\\r')\n\t\tfor (var i = 0; i < moveUpRows; ++i) this.term.write('\\x1B[F')\n\t\tfor (var i = 0; i < col; ++i) this.term.write('\\x1B[C')\n\n\t\t// Replace input\n\t\tthis._input = newInput\n\t}\n\n\t/**\n\t * This function completes the current input, calls the given callback\n\t * and then re-displays the prompt.\n\t */\n\tprintAndRestartPrompt(callback) {\n\t\tconst cursor = this._cursor\n\n\t\t// Complete input\n\t\tthis.setCursor(this._input.length)\n\t\tthis.term.write('\\r\\n')\n\n\t\t// Prepare a function that will resume prompt\n\t\tconst resume = () => {\n\t\t\tthis._cursor = cursor\n\t\t\tthis.setInput(this._input)\n\t\t}\n\n\t\t// Call the given callback to echo something, and if there is a promise\n\t\t// returned, wait for the resolution before resuming prompt.\n\t\tconst ret = callback()\n\t\tif (ret == null) {\n\t\t\tresume()\n\t\t} else {\n\t\t\tret.then(resume)\n\t\t}\n\t}\n\n\t/**\n\t * Set the new cursor position, as an offset on the input string\n\t *\n\t * This function:\n\t * - Calculates the previous and current\n\t */\n\tsetCursor(newCursor) {\n\t\tif (newCursor < 0) newCursor = 0\n\t\tif (newCursor > this._input.length) newCursor = this._input.length\n\n\t\t// Apply prompt formatting to get the visual status of the display\n\t\tconst inputWithPrompt = this.applyPrompts(this._input)\n\t\tconst inputLines = countLines(\n\t\t\tinputWithPrompt,\n\t\t\tthis._termSize.cols,\n\t\t)\n\n\t\t// Estimate previous cursor position\n\t\tconst prevPromptOffset = this.applyPromptOffset(\n\t\t\tthis._input,\n\t\t\tthis._cursor,\n\t\t)\n\t\tconst { col: prevCol, row: prevRow } = offsetToColRow(\n\t\t\tinputWithPrompt,\n\t\t\tprevPromptOffset,\n\t\t\tthis._termSize.cols,\n\t\t)\n\n\t\t// Estimate next cursor position\n\t\tconst newPromptOffset = this.applyPromptOffset(\n\t\t\tthis._input,\n\t\t\tnewCursor,\n\t\t)\n\t\tconst { col: newCol, row: newRow } = offsetToColRow(\n\t\t\tinputWithPrompt,\n\t\t\tnewPromptOffset,\n\t\t\tthis._termSize.cols,\n\t\t)\n\n\t\t// Adjust vertically\n\t\tif (newRow > prevRow) {\n\t\t\tfor (let i = prevRow; i < newRow; ++i) this.term.write('\\x1B[B')\n\t\t} else {\n\t\t\tfor (let i = newRow; i < prevRow; ++i) this.term.write('\\x1B[A')\n\t\t}\n\n\t\t// Adjust horizontally\n\t\tif (newCol > prevCol) {\n\t\t\tfor (let i = prevCol; i < newCol; ++i) this.term.write('\\x1B[C')\n\t\t} else {\n\t\t\tfor (let i = newCol; i < prevCol; ++i) this.term.write('\\x1B[D')\n\t\t}\n\n\t\t// Set new offset\n\t\tthis._cursor = newCursor\n\t}\n\n\t/**\n\t * Move cursor at given direction\n\t */\n\thandleCursorMove(dir) {\n\t\tif (dir > 0) {\n\t\t\tconst num = Math.min(dir, this._input.length - this._cursor)\n\t\t\tthis.setCursor(this._cursor + num)\n\t\t} else if (dir < 0) {\n\t\t\tconst num = Math.max(dir, -this._cursor)\n\t\t\tthis.setCursor(this._cursor + num)\n\t\t}\n\t}\n\n\t/**\n\t * Erase a character at cursor location\n\t */\n\thandleCursorErase(backspace) {\n\t\tconst { _cursor, _input } = this\n\t\tif (backspace) {\n\t\t\tif (_cursor <= 0) return\n\t\t\tconst newInput =\n\t\t\t\t_input.substr(0, _cursor - 1) + _input.substr(_cursor)\n\t\t\tthis.clearInput()\n\t\t\tthis._cursor -= 1\n\t\t\tthis.setInput(newInput, false)\n\t\t} else {\n\t\t\tconst newInput =\n\t\t\t\t_input.substr(0, _cursor) + _input.substr(_cursor + 1)\n\t\t\tthis.setInput(newInput)\n\t\t}\n\t}\n\n\t/**\n\t * Insert character at cursor location\n\t */\n\thandleCursorInsert(data) {\n\t\tconst { _cursor, _input } = this\n\t\tconst newInput =\n\t\t\t_input.substr(0, _cursor) + data + _input.substr(_cursor)\n\t\tthis._cursor += data.length\n\t\tthis.setInput(newInput)\n\t}\n\n\t/**\n\t * Handle input completion\n\t */\n\thandleReadComplete() {\n\t\tif (this.history) {\n\t\t\tthis.history.push(this._input)\n\t\t}\n\t\tif (this._activePrompt) {\n\t\t\tthis._activePrompt.resolve(this._input)\n\t\t\tthis._activePrompt = null\n\t\t}\n\t\tthis.term.write('\\r\\n')\n\t\tthis._active = false\n\t}\n\n\t/**\n\t * Handle terminal resize\n\t *\n\t * This function clears the prompt using the previous configuration,\n\t * updates the cached terminal size information and then re-renders the\n\t * input. This leads (most of the times) into a better formatted input.\n\t */\n\thandleTermResize(data) {\n\t\tconst { rows, cols } = data\n\t\tthis.clearInput()\n\t\tthis._termSize = { cols, rows }\n\t\tthis.setInput(this._input, false)\n\t}\n\n\t/**\n\t * Handle terminal input\n\t */\n\thandleTermData(data) {\n\t\tif (!this._active) return\n\n\t\t// If we have an active character prompt, satisfy it in priority\n\t\tif (this._activeCharPrompt != null) {\n\t\t\tthis._activeCharPrompt.resolve(data)\n\t\t\tthis._activeCharPrompt = null\n\t\t\tthis.term.write('\\r\\n')\n\t\t\treturn\n\t\t}\n\n\t\t// If this looks like a pasted input, expand it\n\t\tif (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\n\t\t\tconst normData = data.replace(/[\\r\\n]+/g, '\\r')\n\t\t\tArray.from(normData).forEach(c => this.handleData(c))\n\t\t} else {\n\t\t\tthis.handleData(data)\n\t\t}\n\t}\n\n\t/**\n\t * Handle a single piece of information from the terminal.\n\t */\n\thandleData(data) {\n\t\tif (!this._active) return\n\t\tconst ord = data.charCodeAt(0)\n\t\tlet ofs\n\n\t\t// Handle ANSI escape sequences\n\t\tif (ord == 0x1b) {\n\t\t\tswitch (data.substr(1)) {\n\t\t\t\tcase '[A': // Up arrow\n\t\t\t\t\tif (this.history) {\n\t\t\t\t\t\tlet value = this.history.getPrevious()\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tthis.setInput(value)\n\t\t\t\t\t\t\tthis.setCursor(value.length)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '[B': // Down arrow\n\t\t\t\t\tif (this.history) {\n\t\t\t\t\t\tlet value = this.history.getNext()\n\t\t\t\t\t\tif (!value) value = ''\n\t\t\t\t\t\tthis.setInput(value)\n\t\t\t\t\t\tthis.setCursor(value.length)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '[D': // Left Arrow\n\t\t\t\t\tthis.handleCursorMove(-1)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '[C': // Right Arrow\n\t\t\t\t\tthis.handleCursorMove(1)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '[3~': // Delete\n\t\t\t\t\tthis.handleCursorErase(false)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '[F': // End\n\t\t\t\t\tthis.setCursor(this._input.length)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '[H': // Home\n\t\t\t\t\tthis.setCursor(0)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'b': // ALT + LEFT\n\t\t\t\t\tofs = closestLeftBoundary(this._input, this._cursor)\n\t\t\t\t\tif (ofs != null) this.setCursor(ofs)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'f': // ALT + RIGHT\n\t\t\t\t\tofs = closestRightBoundary(this._input, this._cursor)\n\t\t\t\t\tif (ofs != null) this.setCursor(ofs)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '\\x7F': // CTRL + BACKSPACE\n\t\t\t\t\tofs = closestLeftBoundary(this._input, this._cursor)\n\t\t\t\t\tif (ofs != null) {\n\t\t\t\t\t\tthis.setInput(\n\t\t\t\t\t\t\tthis._input.substr(0, ofs) +\n\t\t\t\t\t\t\t\tthis._input.substr(this._cursor),\n\t\t\t\t\t\t)\n\t\t\t\t\t\tthis.setCursor(ofs)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Handle special characters\n\t\t} else if (ord < 32 || ord === 0x7f) {\n\t\t\tswitch (data) {\n\t\t\t\tcase '\\r': // ENTER\n\t\t\t\t\tif (isIncompleteInput(this._input)) {\n\t\t\t\t\t\tthis.handleCursorInsert('\\n')\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleReadComplete()\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '\\x7F': // BACKSPACE\n\t\t\t\t\tthis.handleCursorErase(true)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '\\t': // TAB\n\t\t\t\t\tif (this._autocompleteHandlers.length > 0) {\n\t\t\t\t\t\tconst inputFragment = this._input.substr(0, this._cursor)\n\t\t\t\t\t\tconst hasTailingSpace =\n\t\t\t\t\t\t\thasTailingWhitespace(inputFragment)\n\t\t\t\t\t\tconst candidates = collectAutocompleteCandidates(\n\t\t\t\t\t\t\tthis._autocompleteHandlers,\n\t\t\t\t\t\t\tinputFragment,\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\t// Sort candidates\n\t\t\t\t\t\tcandidates.sort()\n\n\t\t\t\t\t\t// Depending on the number of candidates, we are handing them in\n\t\t\t\t\t\t// a different way.\n\t\t\t\t\t\tif (candidates.length === 0) {\n\t\t\t\t\t\t\t// No candidates? Just add a space if there is none already\n\t\t\t\t\t\t\tif (!hasTailingSpace) {\n\t\t\t\t\t\t\t\tthis.handleCursorInsert(' ')\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (candidates.length === 1) {\n\t\t\t\t\t\t\t// Just a single candidate? Complete\n\t\t\t\t\t\t\tconst lastToken = getLastToken(inputFragment)\n\t\t\t\t\t\t\tthis.handleCursorInsert(\n\t\t\t\t\t\t\t\tcandidates[0].substr(lastToken.length) + ' ',\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tcandidates.length <= this.maxAutocompleteEntries\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// search for a shared fragement\n\t\t\t\t\t\t\tconst sameFragment = getSharedFragment(\n\t\t\t\t\t\t\t\tinputFragment,\n\t\t\t\t\t\t\t\tcandidates,\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t// if there's a shared fragement between the candidates\n\t\t\t\t\t\t\t// print complete the shared fragment\n\t\t\t\t\t\t\tif (sameFragment) {\n\t\t\t\t\t\t\t\tconst lastToken = getLastToken(inputFragment)\n\t\t\t\t\t\t\t\tthis.handleCursorInsert(\n\t\t\t\t\t\t\t\t\tsameFragment.substr(lastToken.length),\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If we are less than maximum auto-complete candidates, print\n\t\t\t\t\t\t\t// them to the user and re-start prompt\n\t\t\t\t\t\t\tthis.printAndRestartPrompt(() => {\n\t\t\t\t\t\t\t\tthis.printWide(candidates)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If we have more than maximum auto-complete candidates, print\n\t\t\t\t\t\t\t// them only if the user acknowledges a warning\n\t\t\t\t\t\t\tthis.printAndRestartPrompt(() =>\n\t\t\t\t\t\t\t\tthis.readChar(\n\t\t\t\t\t\t\t\t\t`Display all ${candidates.length} possibilities? (y or n)`,\n\t\t\t\t\t\t\t\t).then(yn => {\n\t\t\t\t\t\t\t\t\tif (yn == 'y' || yn == 'Y') {\n\t\t\t\t\t\t\t\t\t\tthis.printWide(candidates)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleCursorInsert('    ')\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase '\\x03': // CTRL+C\n\t\t\t\t\tthis.setCursor(this._input.length)\n\t\t\t\t\tthis.term.write(\n\t\t\t\t\t\t'^C\\r\\n' + ((this._activePrompt || {}).prompt || ''),\n\t\t\t\t\t)\n\t\t\t\t\tthis._input = ''\n\t\t\t\t\tthis._cursor = 0\n\t\t\t\t\tif (this.history) this.history.rewind()\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Handle visible characters\n\t\t} else {\n\t\t\tthis.handleCursorInsert(data)\n\t\t}\n\t}\n}\n","import LocalEchoController from './lib/LocalEchoController'\nexport { HistoryController } from './lib/HistoryController'\n\nexport default LocalEchoController\n"],"names":["exports","parse","CONTROL","join","controlRE","RegExp","META","hash","TOKEN","i","Math","random","toString","startsWithToken","module","s","env","opts","mapped","string","BS","escape","chunker","matches","r","matchObj","origIndex","lastIndex","exec","push","index","matchAll","length","commented","map","match","test","op","quote","esc","out","isGlob","c","charAt","parseEnvVar","commentObj","comment","slice","pattern","varend","varname","char","Error","indexOf","slicedFromI","pre","key","JSON","stringify","getVar","reduce","prev","arg","concat","parseInternal","acc","xs","split","filter","Boolean","x","replace","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","HistoryController","size","_classCallCheck","this","entries","cursor","value","entry","trim","pop","idx","max","min","wordBoundaries","input","leftSide","arguments","words","rx","closestLeftBoundary","offset","found","reverse","find","offsetToColRow","maxCols","row","col","countLines","hasTailingWhitespace","getLastToken","getSharedFragment","fragment","candidates","oldFragment","startsWith","LocalEchoController","term","options","_handleTermData","handleTermData","bind","_handleTermResize","handleTermResize","history","historySize","maxAutocompleteEntries","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_activeCharPrompt","_termSize","cols","rows","_disposables","loadAddon","attach","detach","off","forEach","dispose","on","onData","onResize","fn","_len","args","Array","_key","findIndex","e","splice","prompt","_this","continuationPrompt","Promise","resolve","reject","write","_this2","reason","message","print","normInput","items","padding","println","itemWidth","width","item","wideCols","floor","wideRows","ceil","rowStr","repeat","applyPrompts","substr","currentPrompt","allRows","_offsetToColRow","applyPromptOffset","moveRows","newInput","clearInput","newPrompt","newCursor","newLines","_offsetToColRow2","moveUpRows","callback","_this3","setCursor","resume","setInput","ret","then","inputWithPrompt","_offsetToColRow3","prevCol","prevRow","_offsetToColRow4","newCol","newRow","dir","num","backspace","data","_this4","charCodeAt","normData","from","handleData","_this5","ofs","ord","getPrevious","getNext","handleCursorMove","handleCursorErase","endsWith","isIncompleteInput","handleReadComplete","handleCursorInsert","inputFragment","hasTailingSpace","callbacks","tokens","expr","_ref","apply","console","error","txt","collectAutocompleteCandidates","sort","lastToken","sameFragment","printAndRestartPrompt","printWide","readChar","yn","rewind"],"sourceRoot":""}